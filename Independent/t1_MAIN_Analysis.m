function t1_MAIN_Analysis(app)
%t1_MAIN_Analysis = Main function that guide through all the steps of
%   analysis of the fluorescence signal(s) in tab 1 of WHISIT. It is
%   initiated by START bush button in tab 1 of WHISIT.
%
% There are three possible algorithm for analysis: AIS (Average Intesity of
% Signal), PL (Polar Localization of signal) and M2P (Membrane to Poles
% segmentation). Details of their operation is in the respective functions:
% -> Analysis_AIS
% -> Analysis_PL
% -> Analysis_M2P
% 
% The major steps of the algorithm are the following:
%
% --- STEP 1 = Check that stack and files have equal sizes
%
% --- STEP 2 = Perform analysis of fluorescence signal and of cell
%              detection outline
%
% --- STEP 3 = Save files: the results.mat, the tab-separated.txt and, if
%              necessary, the cloneList.mat.
%
% INPUT ------------------------------------------------------------------
% Are gathered from the selection and path provided using WHISIT interface.
% The major ones include:
% - BF stack of images
% - Channel 1 stack of images
% - Channel 2 stack of images
%   (all must be .tif and in the name format is AnyExpName_XXXX.tif, where 
%   XXXX defining individual frames. Must start at 1)
%
% - DETection.mat file: result from cell detection in the bright field
%   generated by program Outfi. cellList is the most important variable 
%   that will be used for the analysis in this function
%
% - Several parameters, general or specific to an algorithm, can be chosen 
%   by the user using WHISIT interface.
% 
% OUTPUT ------------------------------------------------------------------
% Unless stopped during analysis, several outputs are automatically 
% generated:
% - Res.mat
% - Data.txt
% - clone_List.mat (optional)
%
%
%
% The Main function should be compatible with any detection file (Det.mat)
% genrated by Oufti. Accordin to options and parameters choosen in the GUI 
% the function t1_MAIN_Analysis perform additional evaluations:
%
% -1- Up to three channels are analysed. Channel 1 must be always provided
%     even if only one channel is to be analysed (and it must be Ch. 1) 
%
% -2- Channel 3 can be provided (irrespective of channel 2) and if
%     spotFinder function was performed for this channel, this information
%     is used to rearrenge cell's meshes so that they are oriented such 
%     that the first point in meshes ("Marked" pole) is the closest to the
%     brightest spot found in the cell
%
% -3- If manual tracking was performed, after main analysis of the
%     fluorescence channel(s) the algorithm can combined both information 
%     to assign cell meshes to every time point of each track: 
%     - Lng_Analysis_Tracks
%
% -4- If spot detection was performed, spots can be sinply analysed or used
%     to mark a specific pole and reorient the cell meshes in accordingly:
%     - Adj_MarkedPole
%
%
% -------------------------------------------------------------------------
% Author: Matteo Sangermani
% e-mail: matteo.sangermani@unibas.ch
% Release: 1.0
% Release date: 2019
% -------------------------------------------------------------------------


global APP_opt;                    % stores parameters to run WHISIT

% Keep track of maximum Length of the Profile line(s) and segmentation
% found, to help formatting when saving data and plotting.
APP_opt.Len_AxSig = [];         
APP_opt.Len_SegmSig = [];
APP_opt.Len_PerimSig = [];
                                   

%% --- STEP 1 -------------------------------------------------------------
% Check that all images have same size and same number of images. Also make
% sure that the detection.mat file has length equal to the number of stack
% images provided

% Load DET.mat file from Oufti
if isempty(APP_opt.t1_path_Det) || isempty(APP_opt.t1_file_Det)
    app.TextOUT.Value = sprintf('\n%s\n%s',  '!!! Detection file not provided !!!');
    APP_opt.ERROR = 1;          return;
end
app.TextOUT.Value = sprintf('\n%s',  'Loading Det.mat file' );
load([APP_opt.t1_path_Det , APP_opt.t1_file_Det ]);
app.TextOUT.Value = sprintf('\n%s',  'Processing ...' );
% varlist = store variables present in Det.mat file. Doing spoFinder
% function, it can happen that some secondary variable is missing.
% Then at the end we same the "list" of variable, so we do not need to name
% them and ensure they actually exists
varlist = who('-file', [APP_opt.t1_path_Det , APP_opt.t1_file_Det]);


% Check that Detection.mat file is at most as long as the number of images
% provided in the stack

len_CH1 = length(APP_opt.t1_srcFiles_CH1);
if len_CH1 < length(cellList.meshData)
    app.TextOUT.Value = sprintf('\n%s\n%s',   '!!! Det.mat file includes more frames than the stack of images provided !!!'); 
    APP_opt.ERROR = 1;          return;
end

% Check that all stacks have the same number of images
if APP_opt.t1_choose_BrightField == 1
    if len_CH1 ~= length(APP_opt.t1_srcFiles_BF )
        app.TextOUT.Value = sprintf('\n%s\n%s',   '!!! Unequal number of frames between the BF and channel 1 !!!'); 
        APP_opt.ERROR = 1;          return;        
    end
end
if APP_opt.t1_choose_Chan_2 == 1
    if len_CH1 ~= length(APP_opt.t1_srcFiles_CH2)
        app.TextOUT.Value = sprintf('\n%s\n%s',   '!!! Unequal number of frames between the BF / Chan. 1 / Chan. 2 !!!'); 
        APP_opt.ERROR = 1;          return;
    end
end
if APP_opt.t1_choose_Chan_3 == 1
    if len_CH1 ~= length(APP_opt.t1_srcFiles_CH3)
        app.TextOUT.Value = sprintf('\n%s\n%s',   '!!! Unequal number of frames between the BF / Chan. 1 / Chan. 2 / Chan. 3 !!!'); 
        APP_opt.ERROR = 1;          return;
    end
end


% Check that the size of images equal between channels: load the first
% frame of each stack available

szCH(:,2) = size(imread([APP_opt.t1_srcFiles_CH1(1).folder  filesep  APP_opt.t1_srcFiles_CH1(1).name]));
if APP_opt.t1_choose_BrightField == 1
    szCH(:,1) = size(imread([APP_opt.t1_srcFiles_BF(1).folder   filesep  APP_opt.t1_srcFiles_BF(1).name]));
end
if APP_opt.t1_choose_Chan_2 == 1  
    szCH(:,3) = size(imread([APP_opt.t1_srcFiles_CH2(1).folder  filesep  APP_opt.t1_srcFiles_CH2(1).name]));
end
if APP_opt.t1_choose_Chan_3 == 1  
    szCH(:,4) = size(imread([APP_opt.t1_srcFiles_CH3(1).folder  filesep  APP_opt.t1_srcFiles_CH3(1).name]));
end

% Remove rows where are present zeros and test that they all have same
% sizes in both width (cols) and height (rows).
szCH = szCH(:, any(szCH));              
rows = all(szCH(1,:) == szCH(1,1)) ;
cols = all(szCH(2,:) == szCH(2,1)) ;
if rows ~= 1  ||  cols ~= 1
    app.TextOUT.Value = sprintf('\n%s\n%s',  '!!! Frames are not equal size !!!');
    APP_opt.ERROR = 1;          return;
end




%% --- STEP 2 --------------------------------------------------------------
% Main body of the function, analyse the fluorescence and cell's meshes

% Count number total number of cell in entire cellList.meshData. Will
% be used as count-down and progression to display in GUI of WHISIT
tot_N_cells = sum(cellfun(@ length, cellList.meshData)) ;

% Initialize images (so that we do not pass empty arguments)
I_BF  = [];
I_CH1 = [];       
I_CH2 = [];       
I_CH3 = [];
tot_frames = length(cellList.meshData) ;
% Counter for number of cell analyse (out of tot_N_cells) 
% [counter displayed in GUI of WHISIT]     
n_c = 0;     	

for ff = 1 : length(cellList.meshData)      % go through all frames

    % ---> LOAD all Frames at time point ff 
    % For each channel frame evaluate the average background signal, the 
    % minimum and maximum pixel value
    % Store in cData a cropped image(s) of the cell in the Bright Field ( + extra-border) 

    if APP_opt.t1_choose_BrightField == 1 
        I_BF  = double( imread( [ APP_opt.t1_path_BF  filesep   APP_opt.t1_foldName_BF  filesep   APP_opt.t1_srcFiles_BF(ff).name]) ); 
    end

    I_CH1 = double( imread( [ APP_opt.t1_path_CH1  filesep  APP_opt.t1_foldName_CH1  filesep  APP_opt.t1_srcFiles_CH1(ff).name]) ); 
    [BkGr_Ch1, min_px_Ch1, max_px_Ch1] = BckGrd_GaussFilt( I_CH1, 2, 4);

    if APP_opt.t1_choose_Chan_2 == 1          
        I_CH2 = double( imread( [ APP_opt.t1_path_CH2  filesep  APP_opt.t1_foldName_CH2  filesep  APP_opt.t1_srcFiles_CH2(ff).name]) ); 
        [BkGr_Ch2, min_px_Ch2, max_px_Ch2] = BckGrd_GaussFilt( I_CH2, 2, 4);
    end  
 
    if APP_opt.t1_choose_Chan_3 == 1        
        I_CH3 = double( imread( [ APP_opt.t1_path_CH3  filesep  APP_opt.t1_foldName_CH3  filesep  APP_opt.t1_srcFiles_CH3(ff).name]) ); 
        [BkGr_Ch3, min_px_Ch3, max_px_Ch3] = BckGrd_GaussFilt( I_CH3, 2, 4);
    end 


    % Go through each cell in ff-th frame and analyse signal(s)
    for cc = 1 : length(cellList.meshData{ff})
        
        % Update the counter displayed in GUI of WHISIT
        n_c = n_c + 1 ;
        app.TextOUT.Value = sprintf('%s\n%s', [ 'Cell  ', num2str(cc), '  in Frame  ' num2str(ff) '  of  ' num2str(tot_frames)], ...
                             [ 'Total cells analysed:  ', num2str(n_c) ,'  of  ', num2str(tot_N_cells) ]);
             
                         
        % Detection in Oufti in rare occasions creates empty cells or, worse, cells with
        % empty meshes. We must ensure non to evaluate such cells
        if ~isempty(cellList.meshData{ff}{cc})  &&  ~isempty(cellList.meshData{ff}{cc}.mesh)
 
            % ---> ASSIGN to cells the fluorescent background information
            cellList.meshData{ff}{cc}.Fluor_Chan(1).Avg_BkGr_value = BkGr_Ch1;       % Avg backgroung pixel value
            cellList.meshData{ff}{cc}.Fluor_Chan(1).Min_px_value   = min_px_Ch1;     % Min pixel value in whole frame
            cellList.meshData{ff}{cc}.Fluor_Chan(1).Max_px_value   = max_px_Ch1;     % Max pixel value in whole frame

            % Set polarity as undefined (polarity = 0).
            cellList.meshData{ff}{cc}.polarity = 0 ; 
        
            if APP_opt.t1_choose_Chan_2 == 1          % if evaluate channel 2
                cellList.meshData{ff}{cc}.Fluor_Chan(2).Avg_BkGr_value = BkGr_Ch2;     % Avg backgroung pixel value
                cellList.meshData{ff}{cc}.Fluor_Chan(2).Min_px_value   = min_px_Ch2;   % Min pixel value in whole frame
                cellList.meshData{ff}{cc}.Fluor_Chan(2).Max_px_value   = max_px_Ch2;   % Max pixel value in whole frame
            end 
 
            if APP_opt.t1_choose_Chan_3 == 1          % if evaluate channel 3
                cellList.meshData{ff}{cc}.Fluor_Chan(3).Avg_BkGr_value = BkGr_Ch3;     % Avg backgroung pixel value
                cellList.meshData{ff}{cc}.Fluor_Chan(3).Min_px_value   = min_px_Ch3;   % Min pixel value in whole frame
                cellList.meshData{ff}{cc}.Fluor_Chan(3).Max_px_value   = max_px_Ch3;   % Max pixel value in whole frame
                
                % If Channel 3 is set as  Marker, reorient the meshes properly
                if APP_opt.t1_CH3_Marker == 1  &&  isfield(cellList.meshData{1,ff}{1,cc},'spots') 
                    cellList.meshData{1,ff}{1,cc} = Adj_MarkedPole(cellList.meshData{1,ff}{1,cc}, I_CH3); 
                end
            end  

            % Save the cell ID and frame of origin
            cellList.meshData{1,ff}{1,cc}.info.Original_Frame = ff ;
            cellList.meshData{1,ff}{1,cc}.info.WHISIT_cellID  = cc ;
            cellList.meshData{1,ff}{1,cc}.info.Oufti_cellID   = cellList.cellId{1,ff}(cc) ;
    
            % ---> ANALYSE Fluorescence channel(s) according to the algorithm chosen
            if APP_opt.choice_AIS == 1 
                cellList.meshData{1,ff}{1,cc} = Analysis_AIS(cellList.meshData{1,ff}{1,cc}, ff, cc, I_BF, I_CH1, I_CH2, I_CH3) ;
            elseif APP_opt.choice_M2P == 1 
                cellList.meshData{1,ff}{1,cc} = Analysis_M2P(cellList.meshData{1,ff}{1,cc}, ff, cc, I_BF, I_CH1, I_CH2, I_CH3) ;
            elseif APP_opt.choice_PL  == 1  
                cellList.meshData{1,ff}{1,cc} = Analysis_PL( cellList.meshData{1,ff}{1,cc}, ff, cc, I_BF, I_CH1, I_CH2, I_CH3) ;
            end


            % ---> DISPLAY the analisys in composite figure(s)
            if APP_opt.choice_plot == 1        
                if     APP_opt.choice_AIS == 1 ;     Display_Cell_AIS(cellList.meshData{1,ff}{1,cc} ) ;
                elseif APP_opt.choice_M2P == 1 ;     Display_Cell_M2P(cellList.meshData{1,ff}{1,cc} ) ;
                elseif APP_opt.choice_PL  == 1 ;     Display_Cell_PL( cellList.meshData{1,ff}{1,cc} ) ;     
                end        
            end        
        end
        
        
        % If STOP button is pressed in GUI, interrupt analysis function
        if APP_opt.BREAK == 1       
            return
        end 
        
        
    end  %for cc
    
end  %for ff




%% --- STEP 3 --------------------------------------------------------------
% SAVE the analysis performed (Res.mat) and export the results in
% appropriate tab-separated .txt files. 


% Create variable WHISIT_param to store the parameters used for analysis
% and save in Res.mat file
% (we will need them especially for Lineage_Plotting (tab_3))
WHISIT_param.choice_AIS = APP_opt.choice_AIS ;
WHISIT_param.choice_M2P = APP_opt.choice_M2P ;
WHISIT_param.choice_PL  = APP_opt.choice_PL ;
WHISIT_param.choice_ManualTrack = any(strcmp(varlist,'cellTrack')) ;

WHISIT_param.eval_BrightField   = APP_opt.t1_choose_BrightField;
WHISIT_param.eval_Channel_1     = 1 ;
WHISIT_param.eval_Channel_2     = APP_opt.t1_choose_Chan_2 ;
WHISIT_param.eval_Channel_3     = APP_opt.t1_choose_Chan_3 ;
WHISIT_param.MarkedPole         = APP_opt.t1_CH3_Marker ;

if APP_opt.t1_CH3_Marker == 1    
    WHISIT_param.eval_Spots  = 'CH3' ;
else
    WHISIT_param.eval_Spots  = '' ;
end

if     APP_opt.choice_AIS == 1
    WHISIT_param.AIS.eval_AxProfile   = APP_opt.AIS_EvalAxisProfile ;     % Chooice to analyse the profile line
    WHISIT_param.AIS.AxWidth          = APP_opt.AIS_AxisWidth ;           % [px] width of the axial profile line analysed
    WHISIT_param.AIS.eval_Type        = APP_opt.AIS_ProfileType ;         %  what type of profile line saved: 1 = mean; 2 = max value

    WHISIT_param.AIS.eval_Segment     = APP_opt.AIS_EvalSegmentation ;    % Chooice to perform cell segmentation
    WHISIT_param.AIS.SegmentLength    = APP_opt.AIS_SegmentLength ;       % length of each segment (in [pixels])

    WHISIT_param.AIS.eval_Perim       = APP_opt.AIS_EvalPerim ;           % Chooice to analyse cell border signal
    WHISIT_param.AIS.PerimWidth       = APP_opt.AIS_PerimWidth ;          % width in [pixel] to consider for the analysis
    WHISIT_param.AIS.PerimSpacing     = APP_opt.AIS_PerimSpacing ;        % Fraction of points to create for a new evenly spaced perimeter

    WHISIT_param.AIS.Len_AxSig        = APP_opt.Len_AxSig ;               % Length of Profile line of all cells         
    WHISIT_param.AIS.Len_SegmSig      = APP_opt.Len_SegmSig ;             % Length of Segmentation line of all cells         
    WHISIT_param.AIS.Len_PerimSig     = APP_opt.Len_PerimSig ;            % Length of Boder perimeter line of all cells         

elseif APP_opt.choice_M2P == 1 
    WHISIT_param.M2P.LateralMemb_Size = APP_opt.M2P_LatMemb  ;       % [px], Thickness lateral areas         
    WHISIT_param.M2P.PoleMemb_Size    = APP_opt.M2P_PoleMemb ;       % [px], Thickness polar areas 
    WHISIT_param.M2P.Polar_Radius     = APP_opt.M2P_PoleRad  ;       % [px], polar circle radius
    
elseif APP_opt.choice_PL  == 1 
    WHISIT_param.PL.Memb_Size         = APP_opt.PL_AllMemb ;         % [px], Thickness all membrane area              
    WHISIT_param.PL.PoleMemb_Size     = APP_opt.PL_PoleMemb ;        % [px], Thickness polar areas 
    WHISIT_param.PL.R_factor          = APP_opt.PL_PoleRad ;         % [px], Radius for final polar area  
    WHISIT_param.PL.Scale_factor      = APP_opt.PL_ScaleFact ;       % 0.7 , [%] Scale factor for search diameter ( = Avg cell width)  
end



% If Manual Tracking was NOT performed, simply save the Res.mat file
% containing the cellList as is.
add_ManualTrack = WHISIT_param.choice_ManualTrack ;
if add_ManualTrack ~= 1 
    % --- SAVE analysis Res.mat file 
    app.TextOUT.Value = sprintf('\n%s',  'Saving Results ... ');
    if isempty(APP_opt.t1_exp_name)
        save([ APP_opt.t1_path_Det  filesep  , 'Res'] , ...
               'WHISIT_param', varlist{:} );
    else
        save([ APP_opt.t1_path_Det  filesep   APP_opt.t1_exp_name , '_', 'Res'],...
               'WHISIT_param', varlist{:} );  
    end

    % --- SAVE .txt file 
    if     APP_opt.choice_AIS == 1 ;       Save_txt_AIS(cellList, WHISIT_param, APP_opt.t1_path_Det, APP_opt.t1_exp_name) ;
    elseif APP_opt.choice_M2P == 1 ;       Save_txt_M2P(cellList, WHISIT_param, APP_opt.t1_path_Det, APP_opt.t1_exp_name) ;
    elseif APP_opt.choice_PL  == 1 ;       Save_txt_PL( cellList, WHISIT_param, APP_opt.t1_path_Det, APP_opt.t1_exp_name) ; 
    end


% If Manual Tracking was performed, reorganize the cellList.meshData to
% according to the tracking and remove all untracked cells.   
% In such case we DO NOT save any .txt file !!!
elseif add_ManualTrack == 1 
    % --- CREATE and SAVE Res_2.mat
    app.TextOUT.Value = sprintf('\n%s', 'Creating Results_D2T ... ');
    
    [cellList.meshData, LG] = Lng_Analysis_Tracks( cellList.meshData , cellTrack );
    
    app.TextOUT.Value = sprintf('\n%s',  'Saving Results_D2T ... ');        
    % we also include cellTrack and LG in Res_Res_D2T.mat. This file cell
    % detection file is still compatible with Oufti, where the user can go
    % back to check and change cell polarity if wished or needed

    if isempty(APP_opt.t1_exp_name)
        save([ APP_opt.t1_path_Det  filesep   'Res_D2T'] ,...
               'cellTrack', 'LG', 'WHISIT_param', varlist{:} );
    else
        save([ APP_opt.t1_path_Det  filesep  APP_opt.t1_exp_name , '_', 'Res_D2T'] ,...
               'cellTrack', 'LG', 'WHISIT_param', varlist{:} );
    end
    
end % if manual_tracking

end






